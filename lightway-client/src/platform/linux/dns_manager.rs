use std::net::IpAddr;

use crate::dns_manager::{DnsManagerError, DnsSetup};
use std::fs;
use std::io::{BufRead, BufReader};
use std::path::Path;

const RESOLV_CONF: &str = "/etc/resolv.conf";
const RESOLV_CONF_BACKUP: &str = "/etc/resolv.conf.lightway-orig";
const RESOLV_CONF_TMP: &str = "/etc/resolv.conf.lightway-new";
const GENERATED_MARKER: &str = "Generated by lightway";

#[derive(Default)]
pub struct DnsManager {
    setup: bool,
}

impl DnsManager {
    /// Checks if a resolv.conf file was generated by lightway by looking for the marker comment
    fn generated_by_lightway(path: &str) -> bool {
        let file = match fs::File::open(path) {
            Ok(file) => file,
            Err(_) => return false,
        };

        let mut reader = BufReader::new(file);
        let mut first_line = String::new();
        match reader.read_line(&mut first_line) {
            Ok(_) => first_line.contains(GENERATED_MARKER),
            Err(_) => false,
        }
    }

    /// Creates a hard link backup of the existing resolv.conf if it exists and wasn't generated by lightway
    /// Since the temporary location is in the same directory a hardlink is always possible
    ///
    /// This is undone by [`DnsManager::restore_previous_config`]
    fn backup_existing_config(&self) -> Result<(), DnsManagerError> {
        if !Path::new(RESOLV_CONF).exists() {
            return Ok(());
        }

        if Self::generated_by_lightway(RESOLV_CONF) {
            return Ok(());
        }

        // Remove existing backup if present
        let _ = fs::remove_file(RESOLV_CONF_BACKUP);

        // Create hard link backup
        fs::hard_link(RESOLV_CONF, RESOLV_CONF_BACKUP)
            .map_err(|e| DnsManagerError::FailedToSetDnsConfig(e.to_string()))?;

        Ok(())
    }

    /// Generates resolv.conf content using provided DNS server
    fn generate_resolv_conf_content(dns_server: IpAddr) -> String {
        format!(
            "# {}\nsearch lightway\nnameserver {}\n",
            GENERATED_MARKER, dns_server
        )
    }

    /// Writes the DNS configuration to resolv.conf atomically using a temporary file
    ///
    /// Cleans up any stale file at a path used by older version of xv_engine to
    /// store the resolve.conf (which was then symlinked to /etc/resolv/conf) since
    /// at this point it cannot possibly be in use any more
    fn apply_configuration(&self, content: &str) -> Result<(), DnsManagerError> {
        fs::write(RESOLV_CONF_TMP, content)
            .map_err(|e| DnsManagerError::FailedToSetDnsConfig(e.to_string()))?;

        fs::rename(RESOLV_CONF_TMP, RESOLV_CONF)
            .map_err(|e| DnsManagerError::FailedToSetDnsConfig(e.to_string()))?;

        Ok(())
    }

    /// Restores the original resolv.conf from backup if the current one was generated by lightway
    fn restore_previous_config(&self) -> Result<(), DnsManagerError> {
        if !Self::generated_by_lightway(RESOLV_CONF) {
            let _ = fs::remove_file(RESOLV_CONF_BACKUP);
            return Ok(());
        }

        match fs::rename(RESOLV_CONF_BACKUP, RESOLV_CONF) {
            Ok(()) => Ok(()),
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                Err(DnsManagerError::NoResolvConfBackup)
            }
            Err(e) => Err(DnsManagerError::FailedToRestoreDnsConfig(e.to_string())),
        }
    }
}

impl DnsSetup for DnsManager {
    fn set_dns(&mut self, dns_server: IpAddr) -> Result<(), DnsManagerError> {
        if self.setup {
            return Err(DnsManagerError::DnsAlreadyConfigured);
        }
        self.backup_existing_config()?;

        let content = Self::generate_resolv_conf_content(dns_server);

        self.apply_configuration(&content)?;

        self.setup = true;
        Ok(())
    }

    fn reset_dns(&mut self) -> Result<(), DnsManagerError> {
        if self.setup {
            self.restore_previous_config()?;
        }
        self.setup = false;
        Ok(())
    }
}

impl Drop for DnsManager {
    fn drop(&mut self) {
        if let Err(e) = self.reset_dns() {
            tracing::warn!("Failed to reset DNS configuration during cleanup: {:?}", e);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;
    use std::env;
    use test_case::test_case;

    const TEST_IP_ADDR: IpAddr = IpAddr::V4(std::net::Ipv4Addr::new(8, 8, 8, 8));

    #[serial]
    fn test_generated_content_passes_lightway_check() {
        let content = DnsManager::generate_resolv_conf_content(TEST_IP_ADDR);

        test_file_detection_with_content(true, &content);
    }

    #[test_case(false, "nameserver 8.8.8.8\nsearch example.com\n" ; "regular resolv conf")]
    #[test_case(false, "" ; "empty file")]
    #[test_case(false, "nameserver 8.8.8.8\n# Generated by lightway\n" ; "marker in wrong position")]
    #[serial]
    fn test_file_detection_with_content(expected: bool, content: &str) {
        let temp_path = env::temp_dir().join("test_file_detection");
        fs::write(&temp_path, content).unwrap();

        assert_eq!(
            DnsManager::generated_by_lightway(temp_path.to_str().unwrap()),
            expected
        );

        let _ = fs::remove_file(&temp_path);
    }

    #[test]
    fn test_missing_file_detection() {
        assert!(!DnsManager::generated_by_lightway("/nonexistent/path"));
    }

    #[test]
    fn test_content_format() {
        let content = DnsManager::generate_resolv_conf_content(TEST_IP_ADDR);
        let lines: Vec<&str> = content.lines().collect();

        assert_eq!(lines[0], format!("# {GENERATED_MARKER}"));
        assert_eq!(lines[1], "search lightway");
        assert_eq!(lines[2], "nameserver 8.8.8.8");
    }

    #[test]
    fn test_dns_already_configured_error() {
        let mut dns_manager = DnsManager { setup: true };
        let result = dns_manager.set_dns(TEST_IP_ADDR);

        assert!(matches!(result, Err(DnsManagerError::DnsAlreadyConfigured)));
    }
}
